""" Create version header and tracker file if missing """
import datetime
import os

Import("env")

# VERSION DATA HANDLING #
#########################
VERSION_FILE = 'ProjVersion'
VERSION_HEADER = 'ProjVersion.h'
VERSION_MAJOR   = 0
VERSION_UNO     = "VERSION_UNO" # second number is the uno version
VERSION_ESP     = 0

PROJECT_DIR = env.subst("$PROJECT_DIR")
INCLUDE_DIR = os.path.join(PROJECT_DIR, "include")
RESOURCES_DIR = os.path.join(PROJECT_DIR, "resources")

if not os.path.exists(".version_no_increment"):
    try:
        with open(VERSION_FILE) as FILE:
            VERSION_FILE_DATA = FILE.readline()
            print(VERSION_FILE_DATA)

            VERSION_MAJOR, VERSION_FILE_DATA = VERSION_FILE_DATA.split(',',1)
            VERSION_UNO, VERSION_ESP = VERSION_FILE_DATA.split(',',1)   #keep uno as string (is a define) 
            # convert to integer 
            VERSION_MAJOR = int(VERSION_MAJOR.strip())
            VERSION_ESP = int(VERSION_ESP.strip())

            if not os.path.exists(".version_no_increment_update_date"):
                VERSION_ESP = VERSION_ESP + 1
    except:
        print('No version file found or incorrect data in it. Starting from 0,VERSION_UNO,0')
        VERSION_ESP = 0

    if VERSION_ESP > 255:
        raise Exception("Version does not fit into uint8_t!!!")

    # create prefix string  e.g. 0,UNO_VERS,
    VERSION_PREFIX = (str(VERSION_MAJOR) + "," + VERSION_UNO + ",")

    with open(VERSION_FILE, 'w+') as FILE:
        FILE.write(VERSION_PREFIX + str(VERSION_ESP))
        print('Build number: {}'.format(VERSION_PREFIX + str(VERSION_ESP)))

    VERSION_MAJOR_STR = (str(VERSION_MAJOR))
    VERSION_ESP_STR = (str(VERSION_ESP))

    HEADER_FILE = """
    // AUTO GENERATED FILE, DO NOT EDIT
    #include "AVRHexArray.h" // get uno version stored in the hex array "VERSION_UNO"

    #ifndef PROJECT_MAJOR
        #define PROJECT_MAJOR {}
    #endif
    #ifndef PROJECT_UNO
        #define PROJECT_UNO {}
    #endif
    #ifndef PROJECT_ESP
        #define PROJECT_ESP {}
    #endif

    #ifndef PROJECT_STR_VERSION
        // Create version inforamtion in str format
        #define VERS(version)               #version
        #define VERSION_STR(major,uno,esp)  VERS(major) "." VERS(uno) "." VERS(esp)
        #define PROJECT_STR_VERSION         VERSION_STR(PROJECT_MAJOR, PROJECT_UNO, PROJECT_ESP)
    #endif //PROJECT_STR_VERSION

    #ifndef PROJECT_BUILD_TIMESTAMP
        #define PROJECT_BUILD_TIMESTAMP "{}"
    #endif
    """.format(VERSION_MAJOR_STR, VERSION_UNO, VERSION_ESP_STR, datetime.datetime.now())

    if os.environ.get('PLATFORMIO_INCLUDE_DIR') is not None:
        VERSION_HEADER = os.environ.get('PLATFORMIO_INCLUDE_DIR') + os.sep + VERSION_HEADER
    elif os.path.exists("include"):
        VERSION_HEADER = "include" + os.sep + VERSION_HEADER
    else:
        os.mkdir(PROJECT_DIR + os.sep + "include")
        VERSION_HEADER = "include" + os.sep + VERSION_HEADER

    with open(VERSION_HEADER, 'w+') as FILE:
        FILE.write(HEADER_FILE)

    open('.version_no_increment', 'a').close()
else:
    if os.path.exists("version"):
        FILE = open(VERSION_FILE)
        VERSION_NUMBER = FILE.readline()
        print('Build number: {} (waiting for upload before next increment)'.format(str(VERSION_NUMBER)))
    else:
        print('No version file found or incorrect data in it!!')


# HTML to C header conversion #
###############################

#dict to store the HTML files and their corresponding C array names
C_CONTENT_HEADER_FILE = "WebContent.h"
HTML_DATA = {
    "index_html":           "MainPage.html",
    "logout_html":          "LogoutPage.html",
    "html_content_chart":   "WebChartPage.html",
    "settings_html":        "WebDataSettingsPage.html"
}

# Initialize the C content string
c_content = "/* ****************************************************\n* !!!! AUTO GENERATED FILE, DO NOT EDIT !!!!\n"
c_content += "*\n"
c_content += "* This file is auto-generated by the script version_increment_pre.py\n"
c_content += "* Contains the HTML content converted to rawliteral string in  the C header file.\n"
c_content += "* The input HTML files are stored in the resources folder.\n"
c_content += "* Current confguration: \n"
for key, value in HTML_DATA.items():
    c_content += "* \t{} \t\t--> {}\n".format(value, key)
c_content += "* *****************************************************/\n"

if not os.path.exists(RESOURCES_DIR):
    os.mkdir(RESOURCES_DIR)
    print(f"Created resources directory: {RESOURCES_DIR}")
    print("No HTML files found to convert.") 
else:
    # list all HTML files to be converted
    for key, value in HTML_DATA.items():
        html_file = os.path.join(RESOURCES_DIR, value)
        if not os.path.exists(html_file):
            print(f"HTML file {html_file} does not exist.")
            continue

        # Create the header file name based on the HTML file name
        header_file = os.path.splitext(html_file)[0] + ".h"
        
        with open(html_file, 'r') as f:
            html_content = f.read()

        # Convert HTML to C header format
        c_content += 'const char {}[] PROGMEM = R"rawliteral(\n{}\n)rawliteral";\n\n'.format(key, html_content)
        
    # Select the header file name for the C content
    header_file = os.path.join(INCLUDE_DIR, C_CONTENT_HEADER_FILE)
    # Write the C content to the header file
    with open(header_file, 'w') as f:
        f.write(c_content)
